#+TITLE: Storage layer
A storage layer is a stage in which jobs do not need to be processed.
Instead, they are stored until the corresponding job deadline passed, after which they will be moving on to the next stage.
Additionally, jobs of the same product type may be overlapping in the storage layer.

* Definitions
- A list of jobs $J$.
- A list of products $P$. Each job belongs to production order.
- A list of machines $M$. Each machine is a storage unit. For now, they are all the same, but we can make them unrelated easily (see the unrelated parallel machines code).

Let's define the model.
#+begin_src python
mdl = docp.CpoModel()
#+end_src

* Variables
** Job interval variables
For each job, we define an interval variable. This interval variable has no pre-determined size.

#+begin_src python
tasks = [mdl.interval_var(name=f"T_{j}") for j in range(data.num_jobs)]
#+end_src
** Assignment variables
For each job and machine pair, we introduce another interval variable that represents the assignment variable.
This is a common way in machine scheduling to deal with assigning jobs explicitly to machines.
Using the alternative constraint later on, we select precisely one assignment variable for each job interval variable.

#+begin_src python
assignments = [[mdl.interval_var(name=f"A_{j}_{i}", optional=True) for i in range(data.num_machines)] for j in range(data.num_jobs)]
#+end_src

* Constraints
** Select assignment variable
Pretty standard: we select exactly one assignment interval variable for each job interval variable.
#+begin_src python
def assign_one_machine(data, mdl, tasks, assignments):
    """
    Each job is assigned to exactly one machine by implementing the following
    constraint:

        Alternative(T_j, [A_j_1, ..., A_j_m])
    """
    for j in range(data.num_jobs):
        cons = mdl.alternative(tasks[j], assignments[j])
        mdl.add(cons)
#+end_src

** No overlap on machines for different product types
So here I need to think a bit. In constrast to UPM, we cannot use a NoOverlap constraint on the sequence variable defined on the assignment variables of one machine. This would namely create non-overlapping intervals for all jobs scheduled on the machine, which we do not need.

We want to have NoOverlap on the sequence variable that is defined by the product interval variable.

(This part should be defined earlier, but this is non-linear process)

First, we define a product interval variable for each product type.

#+begin_src python
products = [mdl.interval_var(name=f"P_{j}") for j in range(data.num_products)]
#+end_src

Then we let the products span the corresponding job interval variables.

#+begin_src python
def products_span_jobs(data, mdl, tasks, products):
    """
    Product interval variables span the correposnding job interval varables.
    """
    for p in range(data.num_products):
        jobs = [tasks[j] for j in range(data.num_jobs) if data.job_product[j][p]]
        cons = mdl.span(products[p], jobs)
        mdl.add(cons)


#+end_src

We now define a product assignment.
#+begin_src python
product_assignments = [mdl.interval_var(name=f"P_{j}_{i}") for j in range(data.num_products) for i in range(data.num_machines)]
#+end_src

The product assignment variables should be the same as the ones of the job assignment variables.
We can model this using the PresenceOf constraint. TODO: can we use a global constraint for this?

#+begin_src python
def job_product_assignments_same(data, mdl, assignments, product_assignments):
    for product in range(data.num_products):
        for job in range(data.num_jobs):
            if data.job_product[j][p]:
                for machine in range(data.num_machines):
                    cons = mdl.presence_of(assignments[j][m]) == mdl.presence_of(product_assignments[p][m])
                    mdl.add(cons)
#+end_src

The sequences are defined on the product assignment variables.
#+begin_src python

#+end_src
